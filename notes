Okay, this is a substantial refactoring. I will rewrite the entire code with libxo integration and add comments explaining the changes.

Key principles for libxo integration:

Initialization & Argument Parsing: xo_parse_args() at the beginning.

Top-Level Structure: Use xo_open_list() and xo_close_list() to define a list of file entries.

Headers: Use xo_emit_h() or xo_emit("{T:...}") for column headers.

Data Emission:

Use xo_open_instance() and xo_close_instance() for each individual file record.

Replace printf with xo_emit("{[:<modifier>]<field_name>/<format>}", value); for data fields.

Field names should be descriptive for structured output (JSON/XML).

The format specifier after / controls the human-readable output.

Error Handling: Use xo_errx(), xo_warnx(), etc.

Usage/Help: Update usage() to use xo_emit_h() and include xo_emit_help().

Let's go through the code section by section.

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2009 Stanislav Sedov <stas@FreeBSD.org>
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/user.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/sysctl.h>
#include <sys/queue.h>
#include <sys/un.h>

#include <netinet/in.h>

#include <arpa/inet.h>

#include <assert.h>
#include <ctype.h>
// #include <err.h> // Will be replaced by libxo error functions
#include <libprocstat.h>
#include <limits.h>
#include <pwd.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>

#include <libxo/xo.h> // XO: Include libxo header

#include "functions.h" // Assuming do_fstat is part of a larger context

static int 	fsflg,	/* show files on same filesystem as file(s) argument */
		pflg,	/* show files open by a particular pid */
		sflg,	/* show socket details */
		uflg;	/* show files open by a particular (effective) user */
static int 	checkfile; /* restrict to particular files or filesystems */
static int	nflg;	/* (numerical) display f.s. and rdev as dev_t */
static int	mflg;	/* include memory-mapped files */
static int	vflg;	/* be verbose */

typedef struct devs {
	struct devs	*next;
	uint64_t	fsid;
	uint64_t	ino;
	const char	*name;
} DEVS;

static DEVS *devs;
static char *memf, *nlistf;

// Forward declarations
static int	getfname(const char *filename);
static void	dofiles(struct procstat *procstat, struct kinfo_proc *p);
static void	print_access_flags(int flags);
static void	print_file_info(struct procstat *procstat,
    struct filestat *fst, const char *uname, const char *cmd, int pid);
static void	print_pipe_info(struct procstat *procstat,
    struct filestat *fst);
static void	print_pts_info(struct procstat *procstat,
    struct filestat *fst);
static void	print_sem_info(struct procstat *procstat,
    struct filestat *fst);
static void	print_shm_info(struct procstat *procstat,
    struct filestat *fst);
static void	print_socket_info(struct procstat *procstat,
    struct filestat *fst);
static void	print_vnode_info(struct procstat *procstat,
    struct filestat *fst);
static void	usage(void) __dead2;
static char * addr_to_string(struct sockaddr_storage *ss, char *buffer, int buflen);


int
do_fstat(int argc, char **argv)
{
	struct kinfo_proc *p;
	struct passwd *passwd;
	struct procstat *procstat;
	int arg, ch, what;
	int cnt, i;

	arg = 0;
	what = KERN_PROC_PROC;
	nlistf = memf = NULL;

	// XO: Parse libxo arguments first. This modifies argc and argv.
	argc = xo_parse_args(argc, argv);
	if (argc < 0)
		return (1); // Error in xo_parse_args

	while ((ch = getopt(argc, argv, "fmnp:su:vN:M:")) != -1)
		switch((char)ch) {
		case 'f':
			fsflg = 1;
			break;
		case 'M':
			memf = optarg;
			break;
		case 'N':
			nlistf = optarg;
			break;
		case 'm':
			mflg = 1;
			break;
		case 'n':
			nflg = 1;
			break;
		case 'p':
			if (pflg++)
				usage();
			if (!isdigit(*optarg)) {
				// XO: Use xo_warnx for warnings
				xo_warnx("-p requires a process id");
				usage();
			}
			what = KERN_PROC_PID;
			arg = atoi(optarg);
			break;
		case 's':
			sflg = 1;
			break;
		case 'u':
			if (uflg++)
				usage();
			if (!(passwd = getpwnam(optarg)))
				// XO: Use xo_errx for fatal errors
				xo_errx(1, "%s: unknown uid", optarg);
			what = KERN_PROC_UID;
			arg = passwd->pw_uid;
			break;
		case 'v':
			vflg = 1;
			break;
		case '?':
		default:
			usage();
		}

	// XO: Adjust argv based on optind from getopt
	argv += optind;

	if (*argv) { // Original: if (*(argv += optind))
		for (; *argv; ++argv) {
			if (getfname(*argv))
				checkfile = 1;
		}
		if (!checkfile)	/* file(s) specified, but none accessible */
			exit(1); // XO: Consider xo_finish() before exit(1) if initialized
	}

	if (fsflg && !checkfile) {
		/* -f with no files means use wd */
		if (getfname(".") == 0)
			exit(1); // XO: Consider xo_finish()
		checkfile = 1;
	}

	if (memf != NULL)
		procstat = procstat_open_kvm(nlistf, memf);
	else
		procstat = procstat_open_sysctl();

	if (procstat == NULL)
		// XO: Use xo_errx for fatal errors related to procstat
		xo_errx(1, "procstat_open_sysctl() failed: %s", xo_strerror(errno));
	p = procstat_getprocs(procstat, what, arg, &cnt);
	if (p == NULL)
		// XO: Use xo_errx
		xo_errx(1, "procstat_getprocs() failed: %s", xo_strerror(errno));

	// XO: Open a top-level list for all fstat entries
	xo_open_list("fstat-entry");

	/*
	 * Print header.
	 */
	// XO: Emit headers using libxo. {T:...} is for title.
	// The format specifier after / controls human-readable output width.
	// The string inside {T:...} is the field name for structured output.
	xo_emit_h("{T:USER/%-8s}{T:/%-10s}{T:PID/%5s}{T:FD/%4s}", "USER", "CMD", "PID", "FD");
	if (nflg)
		xo_emit_h("{T:DEVICE/%-6s}{T:INODE/%10s}{T:MODE/%12s}{T:SIZE_OR_DEV/%-6s}{T:ACCESS/%3s}",
		    "DEV", "INUM", "MODE", "SZ|DV", "R/W");
	else
		xo_emit_h("{T:MOUNT/%-10s}{T:INODE/%10s}{T:MODE/%12s}{T:SIZE_OR_DEV/%-6s}{T:ACCESS/%3s}",
		    "MOUNT", "INUM", "MODE", "SZ|DV", "R/W");

	if (checkfile && fsflg == 0)
		xo_emit_h("{T:NAME/ %s}", "NAME"); // Note: leading space added to NAME for alignment
	xo_emit_h("\n");


	/*
	 * Go through the process list.
	 */
	for (i = 0; i < cnt; i++) {
		if (p[i].ki_stat == SZOMB)
			continue;
		// dofiles will now handle xo_open_instance/xo_close_instance for each file of this process
		dofiles(procstat, &p[i]);
	}

	// XO: Close the top-level list
	xo_close_list("fstat-entry");

	procstat_freeprocs(procstat, p);
	procstat_close(procstat);

	// XO: Finalize libxo output
	xo_finish();
	return (0);
}

static void
dofiles(struct procstat *procstat, struct kinfo_proc *kp)
{
	const char *cmd;
	const char *uname;
	struct filestat *fst;
	struct filestat_list *head;
	int pid;

	uname = user_from_uid(kp->ki_uid, 0); // Assuming user_from_uid is available
	pid = kp->ki_pid;
	cmd = kp->ki_comm;

	head = procstat_getfiles(procstat, kp, mflg);
	if (head == NULL)
		return;

	STAILQ_FOREACH(fst, head, next) {
		// XO: print_file_info will now handle its own xo_open_instance/xo_close_instance
		// and emit fields for the current file entry.
		print_file_info(procstat, fst, uname, cmd, pid);
	}
	procstat_freefiles(procstat, head);
}


static void
print_file_info(struct procstat *procstat, struct filestat *fst,
    const char *uname, const char *cmd, int pid)
{
	struct vnstat vn; // Used for vnode specific info
	DEVS *d;
	const char *filename_from_arg; // Renamed to avoid conflict
	int error, fsmatch = 0;
	char errbuf[_POSIX2_LINE_MAX];

	filename_from_arg = NULL; // From user-supplied file arguments
	if (checkfile != 0) { // If user specified files/filesystems to filter by
		if (fst->fs_type != PS_FST_TYPE_VNODE &&
		    fst->fs_type != PS_FST_TYPE_FIFO)
			return; // Only check vnodes and fifos against specified files
		error = procstat_get_vnode_info(procstat, fst, &vn, errbuf);
		if (error != 0) {
            // Not much to do if we can't get vnode info for a checked file
            if (vflg) xo_warnx("pid %d, fd %d: could not get vnode info: %s", pid, fst->fs_fd, errbuf);
			return;
        }

		for (d = devs; d != NULL; d = d->next)
			if (d->fsid == vn.vn_fsid) { // Filesystem ID matches
				fsmatch = 1;
				if (d->ino == vn.vn_fileid) { // Inode matches
					filename_from_arg = d->name;
					break;
				}
			}
		if (fsmatch == 0 || (filename_from_arg == NULL && fsflg == 0))
			return; // No match, or not on the same FS and no exact file match
	}

	// XO: Open an instance for this specific file entry
	xo_open_instance("file-details");

	// XO: Emit common prefix information
	xo_emit("{k:user/%-8.8s} {k:command/%-10s} {k:pid/%5d}", uname, cmd, pid);

	// XO: Emit FD type/number
	if (fst->fs_uflags & PS_FST_UFLAG_TEXT)
		xo_emit(" {:fd_description/text%4s}", ""); // %4s for alignment
	else if (fst->fs_uflags & PS_FST_UFLAG_CDIR)
		xo_emit(" {:fd_description/%6s}", "wd"); // Changed from "   wd"
	else if (fst->fs_uflags & PS_FST_UFLAG_RDIR)
		xo_emit(" {:fd_description/%6s}", "root");
	else if (fst->fs_uflags & PS_FST_UFLAG_TRACE)
		xo_emit(" {:fd_description/%6s}", "tr");
	else if (fst->fs_uflags & PS_FST_UFLAG_MMAP)
		xo_emit(" {:fd_description/%6s}", "mmap");
	else if (fst->fs_uflags & PS_FST_UFLAG_JAIL)
		xo_emit(" {:fd_description/%6s}", "jail");
	else if (fst->fs_uflags & PS_FST_UFLAG_CTTY)
		xo_emit(" {:fd_description/%6s}", "ctty");
	else
		xo_emit(" {:fd_number/%4d}", fst->fs_fd);


	/*
	 * Print type-specific data.
	 */
	switch (fst->fs_type) {
	case PS_FST_TYPE_FIFO:
		// For FIFO, print vnode info as it's similar
		xo_emit("{e:file_type/fifo}"); // Add file type explicitly for structured output
		print_vnode_info(procstat, fst); // vnode info also prints access flags
		break;
	case PS_FST_TYPE_VNODE:
		xo_emit("{e:file_type/vnode}");
		print_vnode_info(procstat, fst); // vnode info also prints access flags
		break;
	case PS_FST_TYPE_SOCKET:
		xo_emit("{e:file_type/socket}");
		print_socket_info(procstat, fst); // socket info also prints access flags if applicable
		break;
	case PS_FST_TYPE_PIPE:
		xo_emit("{e:file_type/pipe}");
		print_pipe_info(procstat, fst); // pipe info also prints access flags
		break;
	case PS_FST_TYPE_PTS:
		xo_emit("{e:file_type/pts}");
		print_pts_info(procstat, fst); // pts info also prints access flags
		break;
	case PS_FST_TYPE_SHM:
		xo_emit("{e:file_type/shm}");
		print_shm_info(procstat, fst); // shm info also prints access flags
		break;
	case PS_FST_TYPE_SEM:
		xo_emit("{e:file_type/sem}");
		print_sem_info(procstat, fst); // sem info also prints access flags
		break;
	case PS_FST_TYPE_DEV: // This case was empty, might need specific handling or is covered by VNODE?
        xo_emit("{e:file_type/dev}");
        // For device files that are not vnodes (if any specific info is needed)
        // Often, character/block devices are handled by print_vnode_info
        // If this is for other kinds of devices, fill in details.
        // For now, emit placeholder and access flags.
		xo_emit(" {:device_details/n\\/a%*s}", 28, ""); // Placeholder for alignment
		print_access_flags(fst->fs_fflags);
		break;
	default:	
		xo_emit("{e:file_type/unknown}");
		if (vflg)
			// XO: Use xo_warnx for verbose warnings
			xo_warnx("unknown file type %d for file %d of pid %d",
			    fst->fs_type, fst->fs_fd, pid);
		// XO: Emit placeholders to maintain column alignment for unknown types
		xo_emit(" {:unknown_type_details/n\\/a%*s}", 28, "");
		print_access_flags(fst->fs_fflags); // Still print access if available
	}

	if (filename_from_arg && !fsflg) // If a specific file was matched by arg and not just FS
		// XO: Emit the name of the file if it was specified as an argument
		xo_emit(" {:name_from_argument/ %s}", filename_from_arg);

	// XO: Close the instance for this file entry and emit a newline
	xo_close_instance("file-details");
	xo_emit("\n");
}

static char *
addr_to_string(struct sockaddr_storage *ss, char *buffer, int buflen)
{
	// This function remains largely the same as it's a utility.
	// Its output is used by xo_emit in print_socket_info.
	char buffer2[INET6_ADDRSTRLEN];
	struct sockaddr_in6 *sin6;
	struct sockaddr_in *sin;
	struct sockaddr_un *sun;

	// Ensure buffer is clean for cases where no address is set
	buffer[0] = '\0';

	if (ss == NULL || buflen <= 0) {
        if (buflen > 0) buffer[0] = '\0';
        return buffer;
    }

	switch (ss->ss_family) {
	case AF_LOCAL:
		sun = (struct sockaddr_un *)ss;
		if (sun->sun_path[0] == '\0') // Check for actual empty path
			strlcpy(buffer, "-", buflen);
		else
			strlcpy(buffer, sun->sun_path, buflen);
		break;

	case AF_INET:
		sin = (struct sockaddr_in *)ss;
		if (sin->sin_addr.s_addr == INADDR_ANY && sin->sin_port == 0) {
			strlcpy(buffer, "*:*", buflen); // Handle totally unbound
		} else if (sin->sin_addr.s_addr == INADDR_ANY) {
			snprintf(buffer, buflen, "*:%d", ntohs(sin->sin_port));
		} else if (inet_ntop(AF_INET, &sin->sin_addr, buffer2, sizeof(buffer2)) != NULL) {
			snprintf(buffer, buflen, "%s:%d", buffer2, ntohs(sin->sin_port));
		} else {
			strlcpy(buffer, "bad_inet_addr", buflen);
		}
		break;

	case AF_INET6:
		sin6 = (struct sockaddr_in6 *)ss;
		if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr) && sin6->sin6_port == 0) {
			strlcpy(buffer, "[::]:*", buflen); // Handle totally unbound IPv6
		} else if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
			snprintf(buffer, buflen, "[::]:%d", ntohs(sin6->sin6_port));
		} else if (inet_ntop(AF_INET6, &sin6->sin6_addr, buffer2, sizeof(buffer2)) != NULL) {
			// Use . for port separator for IPv6 for consistency with netstat? Or :
			// FreeBSD netstat uses ".port" for IPv6. Let's stick to that.
			snprintf(buffer, buflen, "%s.%d", buffer2, ntohs(sin6->sin6_port));
		} else {
			strlcpy(buffer, "bad_inet6_addr", buflen);
		}
		break;

	default:
		strlcpy(buffer, "unknown_af", buflen); // Or ""
		break;
	}
	return buffer;
}


static void
print_socket_info(struct procstat *procstat, struct filestat *fst)
{
	static const char *stypename[] = {
		"unused",	/* 0 */
		"stream",	/* 1 */
		"dgram",	/* 2 */
		"raw",		/* 3 */
		"rdm",		/* 4 */
		"seqpak"	/* 5 */
	};
#define STYPEMAX 5
	struct sockstat sock;
	struct protoent *pe;
	char errbuf[_POSIX2_LINE_MAX];
	char src_addr[PATH_MAX], dst_addr[PATH_MAX];
	struct sockaddr_un *sun_local; // Renamed to avoid conflict with utility var
	int error;
	static int isopen_proto; // Renamed to avoid conflict if used elsewhere

	error = procstat_get_socket_info(procstat, fst, &sock, errbuf);
	if (error != 0) {
		// XO: Emit error indication for socket info
		xo_emit(" {:socket_error/error%*s}", 20, ""); // Pad for alignment
		print_access_flags(fst->fs_fflags); // Still print access flags
		return;
	}

	// XO: Emit socket domain and type
	if (sock.type > STYPEMAX)
		xo_emit("*{:socket_domain/%s} {:socket_type_unknown/?%d}", sock.dname, sock.type);
	else
		xo_emit("*{:socket_domain/%s} {:socket_type/%s}", sock.dname, stypename[sock.type]);

	switch (sock.dom_family) {
	case AF_INET:
	case AF_INET6:
		if (!isopen_proto)
			setprotoent(++isopen_proto); // BSD specific: keep proto file open
		if ((pe = getprotobynumber(sock.proto)) != NULL)
			xo_emit(" {:protocol_name/%s}", pe->p_name);
		else
			xo_emit(" {:protocol_number/%d}", sock.proto);
		if (sock.so_pcb != 0)
			xo_emit(" {:pcb_address/%lx}", (unsigned long)sock.so_pcb);
		
		if (sflg) { // Detailed socket info
			addr_to_string(&sock.sa_local, src_addr, sizeof(src_addr));
			addr_to_string(&sock.sa_peer, dst_addr, sizeof(dst_addr));
			xo_emit(" {:local_address/%s} <-> {:peer_address/%s}", src_addr, dst_addr);
		} else {
			// XO: Add padding if sflg is not set to maintain column alignment
			// Estimate width of detailed socket info. This is tricky.
			// For now, just ensure access flags are printed.
		}
		break;
	case AF_UNIX:
		if (sock.so_pcb != 0) {
			xo_emit(" {:pcb_address/%lx}", (unsigned long)sock.so_pcb);
			if (sock.unp_conn) {
				char shoconn[4], *cp;
				cp = shoconn;
				if (!(sock.so_rcv_sb_state & SBS_CANTRCVMORE)) *cp++ = '<';
				*cp++ = '-';
				if (!(sock.so_snd_sb_state & SBS_CANTSENDMORE)) *cp++ = '>';
				*cp = '\0';
				xo_emit(" {:connection_status/%s} {:connected_pcb_address/%lx}",
				    shoconn, (unsigned long)sock.unp_conn);
			}
		}
		if (sflg) {
			sun_local = (struct sockaddr_un *)&sock.sa_local;
			// Print first non-null path for UNIX sockets
			if (sun_local->sun_path[0] != 0) {
				addr_to_string(&sock.sa_local, src_addr, sizeof(src_addr));
			} else { // If local path is empty, try peer
                addr_to_string(&sock.sa_peer, src_addr, sizeof(src_addr));
				if (src_addr[0] == '\0' || strcmp(src_addr, "-") == 0) { // If peer is also empty/default
                    // Provide a placeholder if both are effectively empty
					strlcpy(src_addr, "(no path bound)", sizeof(src_addr));
                }
            }
			xo_emit(" {:unix_socket_path/ %s}", src_addr);
		} else {
             // Padding if not sflg
        }
		break;
	default:
		xo_emit(" {:protocol_number/%d} {:socket_address/%lx}", sock.proto, (unsigned long)sock.so_addr);
	}
	// Access flags are usually not printed for sockets in original fstat, but can be added if needed
	// print_access_flags(fst->fs_fflags); // Uncomment if R/W status is desired for sockets
}

static void
print_pipe_info(struct procstat *procstat, struct filestat *fst)
{
	struct pipestat ps;
	char errbuf[_POSIX2_LINE_MAX];
	int error;

	error = procstat_get_pipe_info(procstat, fst, &ps, errbuf);
	if (error != 0) {
		xo_emit(" {:pipe_error/error%*s}", 20, ""); // Pad
		print_access_flags(fst->fs_fflags);
		return;
	}
	// XO: Emit pipe specific information
	xo_emit("*{:pipe_indicator/pipe} {:pipe_address/%8lx} <-> {:peer_pipe_address/%8lx}",
	    (unsigned long)ps.addr, (unsigned long)ps.peer);
	xo_emit(" {:buffer_count/%6zd}", ps.buffer_cnt);
	print_access_flags(fst->fs_fflags);
}

static void
print_pts_info(struct procstat *procstat, struct filestat *fst)
{
	struct ptsstat pts;
	char errbuf[_POSIX2_LINE_MAX];
	int error;

	error = procstat_get_pts_info(procstat, fst, &pts, errbuf);
	if (error != 0) {
		xo_emit(" {:pts_error/error%*s}", 20, ""); // Pad
		print_access_flags(fst->fs_fflags);
		return;
	}
	// XO: Emit PTS information
	xo_emit("*{:pts_indicator/pseudo-terminal master} ");
	if (nflg || !*pts.devname) {
		xo_emit("{:device_number/%#10jx}", (uintmax_t)pts.dev);
	} else {
		xo_emit("{:device_name/%10s}", pts.devname);
	}
    // The original code did not print size/mode for PTS, just device and access flags.
    // Add padding to align with vnode output if necessary or adjust headers.
    // For now, assuming the fields up to device name/number are enough.
    // SZ|DV and MODE columns would be blank for PTS based on original.
    xo_emit("%19s", ""); // Placeholder for MODE and SZ|DV columns (12 + 1 + 6)
	print_access_flags(fst->fs_fflags);
}

static void
print_sem_info(struct procstat *procstat, struct filestat *fst)
{
	struct semstat sem;
	char errbuf[_POSIX2_LINE_MAX];
	char mode_str[15]; // Buffer for strmode or snprintf
	int error;

	error = procstat_get_sem_info(procstat, fst, &sem, errbuf);
	if (error != 0) {
		xo_emit(" {:sem_error/error%*s}", 20, ""); // Pad
		print_access_flags(fst->fs_fflags);
		return;
	}

	// XO: Emit semaphore path/placeholder, mode, and value
	if (nflg) {
		// For nflg, original has blank DEV/MOUNT and INUM, then octal mode
		xo_emit(" {:sem_dev_placeholder/             }"); // 13 spaces for DEV/MOUNT + INUM
		snprintf(mode_str, sizeof(mode_str), "%o", sem.mode);
		xo_emit(" {:mode_octal/%10s}", mode_str);
	} else {
		// Print path if available, else "-" for DEV/MOUNT
		xo_emit(" {:path/%-15.15s}", fst->fs_path != NULL ? fst->fs_path : "-"); // DEV/MOUNT + INUM
		strmode(sem.mode, mode_str);
		xo_emit(" {:mode_symbolic/%10s}", mode_str);
	}
	xo_emit(" {:value/%6u}", sem.value); // SZ|DV column
	print_access_flags(fst->fs_fflags);
}

static void
print_shm_info(struct procstat *procstat, struct filestat *fst)
{
	struct shmstat shm;
	char errbuf[_POSIX2_LINE_MAX];
	char mode_str[15];
	int error;

	error = procstat_get_shm_info(procstat, fst, &shm, errbuf);
	if (error != 0) {
		xo_emit(" {:shm_error/error%*s}", 20, ""); // Pad
		print_access_flags(fst->fs_fflags);
		return;
	}

	// XO: Emit SHM path/placeholder, mode, and size
	if (nflg) {
		xo_emit(" {:shm_dev_placeholder/             }");
		snprintf(mode_str, sizeof(mode_str), "%o", shm.mode);
		xo_emit(" {:mode_octal/%10s}", mode_str);
	} else {
		xo_emit(" {:path/%-15.15s}", fst->fs_path != NULL ? fst->fs_path : "-");
		strmode(shm.mode, mode_str);
		xo_emit(" {:mode_symbolic/%10s}", mode_str);
	}
	xo_emit(" {:size/%6ju}", (uintmax_t)shm.size); // SZ|DV column
	print_access_flags(fst->fs_fflags);
}

static void
print_vnode_info(struct procstat *procstat, struct filestat *fst)
{
	struct vnstat vn;
	char errbuf[_POSIX2_LINE_MAX];
	char mode_str[15]; // For strmode or snprintf
	const char *badtype;
	int error;

	badtype = NULL;
	error = procstat_get_vnode_info(procstat, fst, &vn, errbuf);
	if (error != 0)
		badtype = errbuf;
	else if (vn.vn_type == PS_FST_VTYPE_VBAD)
		badtype = "bad";
	else if (vn.vn_type == PS_FST_VTYPE_VNON)
		badtype = "none";

	if (badtype != NULL) {
		// XO: Emit placeholder for bad vnode types
		xo_emit(" {:vnode_status/%s%*s}", badtype, (int)(28 - strlen(badtype)),""); // Pad to align
		print_access_flags(fst->fs_fflags); // Still print access flags
		return;
	}

	// XO: Emit filesystem ID or mount point
	if (nflg)
		xo_emit(" {:filesystem_id/%#6jx}", (uintmax_t)vn.vn_fsid); // DEV column
	else if (vn.vn_mntdir != NULL)
		xo_emit(" {:mount_point/%-10.10s}", vn.vn_mntdir); // MOUNT column (adjust width if needed)
	else
		xo_emit(" {:mount_point/%-10s}", "-");


	// XO: Emit inode number
	xo_emit(" {:inode_number/%6jd}", (intmax_t)vn.vn_fileid);

	// XO: Emit mode (octal or symbolic)
	if (nflg) {
		snprintf(mode_str, sizeof(mode_str), "%o", vn.vn_mode);
		xo_emit(" {:mode_octal/%10s}", mode_str);
	} else {
		strmode(vn.vn_mode, mode_str);
		xo_emit(" {:mode_symbolic/%10s}", mode_str);
	}

	// XO: Emit size or device number
	if (vn.vn_type == PS_FST_VTYPE_VBLK || vn.vn_type == PS_FST_VTYPE_VCHR) {
		if (nflg || !*vn.vn_devname)
			xo_emit(" {:device_number_raw/%#6jx}", (uintmax_t)vn.vn_dev);
		else {
			xo_emit(" {:device_name/%6s}", vn.vn_devname);
		}
		xo_emit("{e:is_char_or_block_device/true}");
	} else {
		xo_emit(" {:size/%6ju}", (uintmax_t)vn.vn_size);
		xo_emit("{e:is_char_or_block_device/false}");
	}
	print_access_flags(fst->fs_fflags);
}

static void
print_access_flags(int flags)
{
	char rw[3];
	rw[0] = '\0';
	if (flags & PS_FST_FFLAG_READ)
		strcat(rw, "r");
	if (flags & PS_FST_FFLAG_WRITE)
		strcat(rw, "w");

	// XO: Emit access flags (r, w, rw)
	// Using boolean flags for structured output is often better
	xo_emit("{l:ACCESS}{[:read/%s]}{[:write/%s]}",
	        (flags & PS_FST_FFLAG_READ) ? "r" : "",
	        (flags & PS_FST_FFLAG_WRITE) ? "w" : "");
    // For human readable, we need to combine them with padding.
    // The above will print "r w" or "r " or " w". The header has R/W (3 chars).
    // Let's ensure the human output is like the original:
    // xo_emit(" {:access_flags/%2s}", rw); // This is simpler for direct porting.
    // Let's try to emit both boolean and string for flexibility
    xo_emit(" {:human_access_flags/%2s}", rw);
    xo_emit("{e:access_read/%s}", (flags & PS_FST_FFLAG_READ) ? "true" : "false");
    xo_emit("{e:access_write/%s}", (flags & PS_FST_FFLAG_WRITE) ? "true" : "false");
}

int
getfname(const char *filename)
{
	struct stat statbuf;
	DEVS *cur;

	if (stat(filename, &statbuf)) {
		// XO: Use xo_warn for warnings
		xo_warn("%s", filename);
		return (0);
	}
	if ((cur = malloc(sizeof(DEVS))) == NULL)
		// XO: Use xo_err for fatal errors
		xo_err(1, "malloc failed");
	cur->next = devs;
	devs = cur;

	cur->ino = statbuf.st_ino;
	cur->fsid = statbuf.st_dev;
	cur->name = filename; // Note: filename might not be persistent if it's from argv
	                    // A strdup might be safer if filename's lifetime is shorter than DEVS.
	                    // Given usage, it's likely fine as argv persists.
	return (1);
}

static void
usage(void)
{
	// XO: Emit usage message using xo_emit_h for the main string
	// and xo_emit_help() for standard libxo options.
	xo_emit_h("usage: %s [-fmnsv] [-M core] [-N system] [-p pid] [-u user] [file ...]\n",
	    xo_get_program_name()); // Use xo_get_program_name() for the program name
	xo_emit_help(); // This will print standard libxo help like --libxo json etc.
	xo_finish(); // Ensure libxo flushes before exit
	exit(1);
}

// Dummy user_from_uid if not available from elsewhere, for compilation
#ifndef HAVE_USER_FROM_UID
const char *user_from_uid(uid_t uid, int nouser) {
    struct passwd *pwd = getpwuid(uid);
    if (pwd) {
        return pwd->pw_name;
    }
    // Fallback to numeric UID if user not found
    static char uid_str[16];
    snprintf(uid_str, sizeof(uid_str), "%u", uid);
    return uid_str;
}
#endif // HAVE_USER_FROM_UID


Summary of Changes and Reasoning:

#include <libxo/xo.h>: Added to use libxo functions.

Error Functions: err, errx, warn, warnx replaced with xo_err, xo_errx, xo_warn, xo_warnx respectively. This allows error messages to also be formatted according to libxo styles (e.g., JSON errors).

do_fstat():

xo_parse_args(argc, argv): Called at the beginning to handle libxo command-line options (e.g., --libxo json).

xo_open_list("fstat-entry"): Opens a top-level list for all output records. The name "fstat-entry" will be used as the key for the list in structured formats.

Header Printing: printf replaced with xo_emit_h("{T:FIELD_NAME/%-human_fmt}...", "HUMAN_TEXT"). {T:...} defines a title field. The FIELD_NAME is for structured output, and HUMAN_TEXT with format is for human-readable.

xo_close_list("fstat-entry"): Closes the top-level list.

xo_finish(): Called before exiting to flush libxo buffers and finalize output.

dofiles(): No direct xo_emit calls, but it now iterates and calls print_file_info, which is libxo-aware.

print_file_info():

xo_open_instance("file-details"): Opens a new record/instance for each file.

All printf calls for data are replaced with xo_emit("{[k|e|d]:field_name/%format}", value).

k: for key fields (like pid, user, command).

e: for general data fields (emitted by default).

d: for detail fields (may not be shown in all human formats).

field_name is crucial for structured output.

/format controls human-readable presentation.

Explicitly emits a file_type field for better structured output.

Padding (%*s) or explicit placeholder fields are used in some xo_emit calls to help maintain column alignment in human-readable mode where some file types might not have all data fields that vnodes do. This is a common challenge when porting printf-based tabular output.

xo_close_instance("file-details") and xo_emit("\n"): Closes the record and ensures a newline for human-readable.

print_vnode_info(), print_socket_info(), etc.:

All printfs replaced with xo_emit().

Emit distinct field names for octal vs. symbolic modes, or for device ID vs. mount point, allowing consumers of structured data to choose.

Careful attention to field names and formats.

addr_to_string is a helper; its output is consumed by xo_emit in print_socket_info.

print_access_flags():

Modified to emit both a human-readable combined string (rw) and separate boolean-like fields (access_read, access_write) for structured output clarity.

getfname(): warn and err replaced.

usage():

Uses xo_emit_h() for the main usage string.

xo_get_program_name() is used to get the program name correctly.

xo_emit_help() is called to display standard libxo options (like --libxo json, --pretty).

xo_finish() added before exit(1) to ensure libxo can clean up if usage is called after initialization.

Important Considerations During/After Porting:

Field Naming: Consistency and clarity in field names ({:field_name/...}) are paramount for good structured output.

Human-Readable Alignment: Precisely replicating complex printf alignment with libxo can sometimes be tricky if fields are conditionally present. Using fixed-width format specifiers (%-10s) helps. Sometimes, emitting empty/placeholder fields is necessary.

Testing: Thoroughly test with various libxo output styles (--libxo text, --libxo json, --libxo xml, --libxo html) and options (--pretty, --warn).

libxo Features: Explore more advanced libxo features like roles, units, and format strings if needed for more complex scenarios.

Dependencies: Ensure libxo is a build and runtime dependency. The Makefile or build system will need to be updated to link against libxo (-lxo).

This rewritten code provides a comprehensive libxo integration. The alignment in human-readable mode, especially when some fields are absent for certain file types, might require minor tweaks to the format specifiers or placeholder emissions after testing.
